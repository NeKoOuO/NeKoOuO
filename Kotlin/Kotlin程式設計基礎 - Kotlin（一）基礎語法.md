![image-20230725125851157](https://s2.loli.net/2023/07/29/nCEfGvtyTO3MBzH.png)

# Kotlin程式設計初級篇

**注意：** 在開始學習之前，推薦各位小伙伴有一定的程式語言基礎，前置課程：《JavaSE 教學》或《C 語言程式設計》如果沒有其他語言的基礎，在學習Kotlin時會非常吃力，這門語言語法糖多到爆炸。

Kotlin是一種現代但已經成熟的程式語言，旨在讓開發人員更快樂。它簡潔、安全、可與Java和其他語言互操作，並提供了許多在多個平台之間重用程式碼的方法。它由JetBrains公司於2011年設計和開發，並在2016年正式發布。Kotlin旨在解決Java語言在編碼效率和程式碼質量方面存在的問題，並且與Java語言完全相容。Kotlin透過簡化語法、提供更強大的功能以及減少樣板程式碼的編寫，使得開發者能夠更高效地編寫清晰、簡潔而又安全的程式碼。

> Kotlin語言名字的來源是基於一個古老斯拉夫部落的名字。JetBrains開發Kotlin的初衷是為了在Android開發上取代Java，並且作為一門通用的程式語言。Kotlin透過減少樣板程式碼和增加現代化的語言特性，提供了更好的工具和庫來簡化Android應用開發。由於Kotlin的設計理念和特性吸引了廣泛的開發者關注，它也迅速被接受並得到了廣泛的使用。現在，Kotlin已成為一門流行的程式語言，被許多開發者用於Android應用開發、伺服器端開發以及其他領域的軟體開發中。

官方網站：https://www.jetbrains.com/opensource/kotlin/

![image-20231215224847189](https://s2.loli.net/2023/12/15/58x79t2JvlVZTmo.png)

Kotlin 是一種現代化的靜態類型程式語言，具有以下優勢：

1. 與Java互操作性強：Kotlin 可以與現有的 Java 程式碼無縫地互操作，允許開發者在現有的項目中逐步採用 Kotlin，而不需要重寫整個項目。這使得 Kotlin 成為 Android 應用開發的理想選擇。
2. 簡潔易讀：Kotlin 的語法簡潔並具有更好的可讀性，減少了樣板程式碼的編寫。相比 Java，Kotlin 可以使用更少的程式碼來實現同樣的功能，從而提高開發效率。
3. 空安全性：Kotlin 對空值進行了更好的處理。在 Kotlin 中，變數預設是非空的，如果需要使用可能為空的值，需要顯式宣告類型為可空。這有助於減少空指標異常的發生。
4. 函式式編程支援：Kotlin 支援函式式編程的特性，如高階函式、lambda 表達式和函式式編程的集合操作等。這些特性可以讓開發者編寫更簡潔、可維護的程式碼，並提高程式碼的表達能力。
5. 擴展函式：Kotlin 允許開發者為某個類添加新的方法，而不需要修改該類的原始碼。這種擴展函式的特性可以為開發者提供更靈活的方式來擴展現有的類庫。
6. 共常式支援：Kotlin 引入了共常式（coroutine）機制，使得非同步操作更易於管理和編寫。透過使用共常式，開發者可以使用順序的方式編寫並發程式碼，並避免了回調地獄的問題。

總的來說，Kotlin 是一門功能豐富、可讀性高、與 Java 無縫互操作的程式語言，適用於 Android、Web 後端開發等多種場景。

![image-20230725132203050](https://s2.loli.net/2023/07/29/TpBgQie7CcD2Vol.png)

正是因為Kotlin與Java的高度相容性，再加上簡潔、安全、互操作性強等特點，讓Kotlin一度成為Android開發的官方指定語言。並且隨著時代的發展，現在它不僅僅可以開發安卓應用程式，也可以開發iOS程式，甚至開發Java後端、開發桌面應用程式等。其簡潔高效的語法也受到一眾開發者追捧。

從下節課開始，我們就來正式學習一下Kotlin語言，Kotlin，啟動！

![image-20230725135856171](https://s2.loli.net/2023/07/29/QyjCMSHBn4cdAN3.png)

***

## 走進新語言

歡迎大家進入到Kotlin程式設計的學習中，我們將從開發環境配置開始，為各位小伙伴講解。

程式語言可以被視為人與電腦之間進行交流的方式。它是一種用於編寫電腦程式的形式化語言，用於描述電腦任務的操作步驟、演算法和資料結構。簡單來說，就是以電腦能聽懂的語言告訴電腦我們要做什麼，然後讓電腦來做我們想做的事情，從而解決我們生活中各式各樣的問題。

程式語言可以分為多種類型，包括低級語言和進階語言。低級語言（如組語語言）與電腦硬體更接近，對電腦底層操作進行更精細的控制，但編寫和理解起來較為複雜。進階語言（如Java、Python等）則更加易讀、易寫，並提供了更高層次的抽象，使得程式設計師能夠更專注於問題的解決和演算法的設計。而我們這裡要學習的Kotlin語言，也屬於進階語言的一種，能夠使用我們人類更容易理解的語法來編寫程式。

### 開發環境配置

要開發Kotlin程式，我們首先需要安裝Java環境，我們一般使用Kotlin都是在JVM平台上進行開發（Kotlin同樣可以開發系統原生程式、JavaScript程式、安卓程式、iOS程式等）因為Java支援跨平台，能在編譯後再任意平台上執行，因此，我們將JVM環境中學習Kotlin程式的開發，接下來我們要安裝兩個環境：

* Java 8 環境
* Kotlin 1.9.0 環境

首先我們來安裝Java 8 環境，這裡我們需要去下載JDK，這裡推薦安裝免費的ZuluJDK：https://www.azul.com/downloads/?version=java-8-lts&package=jdk

在這裡選擇自己的作業系統對應的安裝包：

![image-20220916155142546](https://s2.loli.net/2022/09/16/thaGoKI8pXA7Vl6.png)

比如Windows下，我們就選擇`.msi`的安裝包即可（MacOS、Linux下同樣選擇對應的即可）

![image-20220916155242814](https://s2.loli.net/2022/09/16/vjc62OFaqmAegCh.png)

下載完成後，我們直接雙擊安裝：

![image-20220916160027645](https://s2.loli.net/2022/09/16/Loi3Ru7FAWHP6vN.png)

**注意，這裡不建議各位小伙伴去修改安裝的位置！**新手只建議安裝到預設位置（不要總擔心C槽不夠，該裝的還是要裝，尤其是這種環境，實在裝不下就去將其他磁碟的空間分到C槽一部分）如果是因為沒有安裝到預設位置出現了任何問題，你要是找不到大佬問的話，又得重新來一遍，就很麻煩。

剩下的我們只需要一路點擊Next即可，安裝完成之後，我們打開CMD指令視窗（MacOS下直接打開“終端”）來驗證一下（要打開CMD指令視窗，Windows11可以直接在下面的搜尋框搜尋cmd即可，或者直接在文件資源管理器路徑欄輸入cmd也可以）

我們直接輸入java指令即可：

![image-20220916160756046](https://s2.loli.net/2022/09/16/ROD3vkzwT8yFqrc.png)

如果能夠直接輸出內容，說明環境已經安裝成功了，正常情況下已經配置好了，我們不需要手動去配置什麼環境變數，所以說安裝好就別管了。

輸入`java -version`可以查看目前安裝的JDK版本：

![image-20230728003717281](https://s2.loli.net/2023/07/28/WzuBIOierlDSsEF.png)

只要是1.8.0就沒問題了，後面的小版本號可能你們會比我的還要新。

接著是Kotlin 1.9.0 環境，我們需要前往：https://github.com/JetBrains/kotlin/releases 下載最新的Kotlin編譯器並進行安裝：

![image-20230728003925164](https://s2.loli.net/2023/07/28/YotcAjxpWhuGQbS.png)

這裡我們可以直接解壓然後拖入到剛剛Java安裝的同級目錄下，我這裡是 C:\Program Files 資料夾，也可以自訂位置，但是不推薦，因為很多小伙伴配環境直接配到自閉。

然後我們需要手動配置一下環境變數，打開系統環境變數配置：

![image-20230728004205319](https://s2.loli.net/2023/07/28/pmbJioxOuWlNS7q.png)

添加路徑 C:\Program Files\kotlinc\bin 到Path環境變數下即可，然後我們依然打開CMD查看是否安裝成功，輸入`kotlinc -version`來查看安裝情況：

![image-20230728004657590](https://s2.loli.net/2023/07/28/ZWeadTSborCFwsp.png)

這樣我們就完成了所有環境的安裝，我們可以來體驗一下編寫並且編譯執行一個簡單的Kotlin程式，我們建立一個文字文件，命名為`Main.txt`（如果沒有顯示副檔名，需要在文件資源管理器中開啟一下）然後用記事本打開，輸入以下內容：

```kotlin
fun main() {
    println("Hello, World!")
}
```

現在看不懂程式碼沒關係，直接用就行，我們後面會一點一點講解的。

編輯好之後，儲存退出，接著我們將文件的副檔名稱修改為`.kt`這是Java原始程式文件的副檔名稱：

![image-20230728004854748](https://s2.loli.net/2023/07/28/2rqRSVJQG8n5j1L.png)

此時我們打開CMD，注意要先進入到對應的路徑下，比如我們現在的路徑：

![image-20220916161720722](https://s2.loli.net/2022/09/16/8A4oq7XdeLthpmg.png)

我們使用`cd`指令先進入到這個目錄下：

![image-20220916161802753](https://s2.loli.net/2022/09/16/HifR7pVSmqbP4Kh.png)

要編譯一個Kotlin程式，我們需要使用`kotlinc`指令來進行，將我們的程式編譯為jar包，並包含Kotlin的執行時依賴：

```sh
kotlinc Main.kt -include-runtime -d Main.jar
```

執行後，可以看到目錄下多出來了一個`.jar`文件，這是一個打包好的標準Java程式：

![image-20230728005317422](https://s2.loli.net/2023/07/28/zFmwRE2KNkfIWtT.png)

接著我們就可以將其交給JVM執行了，我們直接使用`java -jar`指令即可：

![image-20230728005354810](https://s2.loli.net/2023/07/28/ovDweRJaqAu4Qyx.png)

可以看到列印了一個 Hello World! 字樣，這樣我們的第一個Kotlin程式就成功執行了。

### IDEA安裝與使用

前面我們介紹了Kotlin開發環境的安裝以及成功編譯執行了我們的第一個Kotlin應用程式。

但是我們發現，如果我們以後都使用記事本來進行Kotlin程式開發的話，是不是效率太低了點？我們還要先編輯，然後要改後綴，還要敲指令來編譯，有沒有更加方便一點的寫程式碼的工具呢？這裡我們要介紹的是：**IntelliJ IDEA**（這裡不推薦各位小伙伴使用Eclipse，因為操作上沒有IDEA這麼友好）

IDEA準確來說是一個整合開發環境（IDE），它整合了大量的開發工具，編寫程式碼的錯誤檢測、程式碼提示、一鍵完成編譯執行等，非常方便。

下載網址：[IntelliJ IDEA：JetBrains 功能強大、符合人體工學的 Java IDE](https://www.jetbrains.com.cn/idea/)

![image-20220916162544360](https://s2.loli.net/2022/09/16/UfIQzAXBS7TePm9.png)

我們直接點擊下載即可，注意要下載下面的社群版，不要下載到終極版了：

![image-20230728010334215](https://s2.loli.net/2023/07/28/uFonbh4JNycW1Hd.png)

這個軟體本身是付費的，比較貴，而且最近還漲價了，不過這裡我們直接下載面的社群版本就行了（JavaSE學習階段不需要終極版，但是建議有條件的還是申請一個，功能更強大，體驗更友好）

下載好之後，直接按照即可，這個不強制要求安裝到C槽，自己隨意，但是注意路徑中不要出現中文！


![image-20220916163329410](https://s2.loli.net/2022/09/16/jd64AxEfmQXWTNl.png)

這裡勾選一下建立桌面捷徑就行：

![image-20220916163401880](https://s2.loli.net/2022/09/16/buv9QmapGCENcXn.png)

安裝完成後，我們直接打開就可以了：

![image-20230728011902631](https://s2.loli.net/2023/07/28/g1sK2l5rWRCMnPN.png)

此時介面是全英文，如果各位小伙伴看得慣，可以直接使用全英文的介面（使用英文介面可以認識更多的專業術語詞彙，但是可能看起來沒中文那麼直觀，而且IDEA本身功能就比較多，英語不好的小伙伴就很頭疼）這裡還是建議英語不好的小伙伴使用中文介面，要使用中文只需要安裝中文外掛程式即可：

![image-20230728012014698](https://s2.loli.net/2023/07/28/mLblTjy7GwxCXYe.png)

我們打開Plugins外掛程式這一欄，然後直接在外掛程式市場裡面搜尋Chinese，可以找到一個中文語言包的外掛程式，我們直接Install安裝即可，安裝完成後點擊重啟，現在就是中文頁面了：

![image-20230728012045895](https://s2.loli.net/2023/07/28/3E8pnTgarKuAM6j.png)

如果各位小伙伴不喜歡黑色主題，也可以修改為白色主題，只需要在自訂中進行修改即可，一共四種主題，我們還可以在下面的設定中開啟新UI以及更換各種字體、字體大小等個性化內容。

如果你之前使用過其他IDE編寫程式碼，這裡還支援按鍵映射（採用其他IDE的快捷鍵方案）有需要的可以自己修改一下：

![image-20220916164415447](https://s2.loli.net/2022/09/16/3wbt7QhZmq9EKgY.png)

接下來，我們來看看如何使用IDEA編寫Kotlin程式，IDEA是以項目的形式對一個Java程式進行管理的，所以說我們直接建立一個新的項目，點擊建立項目：

![image-20220916164906998](https://s2.loli.net/2022/09/16/4qvjxmozBaJgOuH.png)

此時來到建立頁面：

![image-20230728012243268](https://s2.loli.net/2023/07/28/OHAYo9gCziRwEnP.png)

- **名稱：** 你的Java項目的名稱，隨便起就行，盡量只帶英文字母和數字，不要出現特殊字元和中文。
- **位置：** 項目的存放位置，可以自己根據情況修改，同樣的，路徑中不要出現中文。
- **語言：** IDEA支援編寫其他語言的項目，但是這裡我們直接選擇Java就行了。
- **構建系統：** 在JavaSE階段一律選擇IntelliJ就行了，Maven我們會在JavaWeb之後進行講解，Gradle會在安卓開發教學中介紹。
- **JDK：** 就是我們之前安裝好的JDK，如果是預設路徑安裝，這裡會自動識別（所以說不要隨便去改，不然這些地方就很麻煩）

當然，如果JDK這裡沒有自動識別到，那麼就手動添加一下：

![image-20220916165351016](https://s2.loli.net/2022/09/16/fDJKB6M3TlWizoQ.png)

沒問題之後，我們直接建立項目：

![image-20230728012604472](https://s2.loli.net/2023/07/28/IvjfL6XTranAJ2y.png)

進入之後，可以看到已經自動幫助我們建立好了一個`kt`來源文件，跟我們之前的例子是一樣的。要編譯執行我們的Kotlin程式，只需要直接點擊左邊的三角形（啟動按鈕）即可：

![image-20230728012647988](https://s2.loli.net/2023/07/28/MhnDTu7Aot9U62F.png)

點擊之後，會在下方自動開始構建：

![image-20230728012720838](https://s2.loli.net/2023/07/28/OjEWI3GlSnkB7mP.png)

完成之後，就可以在控制台看到輸出的內容了：

![image-20230728012737850](https://s2.loli.net/2023/07/28/mbneHTRtjNwasQh.png)

我們可以看到新增加了一個`out`目錄，這裡面就是剛剛編譯好的`.class`文件，這種文件是Java的位元組碼文件，可以直接執行在JVM中：

![image-20230728012808045](https://s2.loli.net/2023/07/28/4t5hgi63QNO9rYJ.png)

IDEA非常強大，即使是編譯之後的位元組碼文件，也可以反編譯回原始碼的樣子：

![image-20230728012917915](https://s2.loli.net/2023/07/28/vfXyUNQBqL2kACO.png)

如果我們想寫一個新的Kotlin項目，可以退出目前項目重新建立：

![image-20230728013013293](https://s2.loli.net/2023/07/28/oVxj4dBwaOgIXc9.png)

此時項目列表中就有我們剛剛建立的Java項目了：

![image-20230728013031657](https://s2.loli.net/2023/07/28/8opBUjILRNrDWyO.png)

如果你還想探索IDEA的其他功能，可以點擊歡迎頁最下方的學習：

![image-20230728013059958](https://s2.loli.net/2023/07/28/jNJ2h7bOAc8ezug.png)

會有一個專門的引導教學項目，來教你如何使用各項功能：

![image-20230728013143382](https://s2.loli.net/2023/07/28/hU8QHKnOy3FbvuC.png)

熟悉了IDEA的使用之後，下節課我們就可以正式地開始學習Kotlin語言的語法了。

### 程式碼基本結構

還記得我們之前使用的範例程式碼嗎？

```kotlin
fun main() {
    println("Hello World!")
}
```

這段程式碼要實現的功能很簡單，就是將 Hello World 這段文字資訊輸出到控制台。

在編寫程式碼時，注意需要區分大小寫，Kotlin語言嚴格區分大小寫，如果我們沒有按照規則來編寫，那麼就會出現紅色波浪線報錯：

![image-20230729013954179](https://s2.loli.net/2023/07/29/RYygkm536VhSDvH.png)

只要原始碼中存在報錯的地方，就無法正常完成編譯得到位元組碼文件，強行執行會提示構建失敗：

![image-20230729014133372](https://s2.loli.net/2023/07/29/L5uFwIJW1ONc3D7.png)

注意這裡包括的花括號是成對出現的，並且一一對應。

所以說各位小伙伴在編寫程式碼時一定要注意大小寫。然後第二行，準確的說是最外層花括號內部就是：

```kotlin
fun main() {
  
}
```

可以看到外面使用花括號前添加了`fun main()`，這是我們整個程式的入口點，我們的Kotlin程式也是從這裡開始從上往下執行的。而其中的`println`語句就是用於列印其括號中包裹的文字，我們可以看到這個文字資訊使用了`""`進行囊括，否則會報錯：

```kotlin
println("Hello World!")
```

這段程式碼的意思就是將雙引號括起來的內容（字串，我們會在後面進行講解）輸出（列印）到控制台上。

比如下面的程式碼，我們就可以實現先列印Hello World!，然後再列印 KFC vivo 50 到控制台：

```kotlin
fun main() {
    println("Hello World!")
    println("KFC vivo 50")
}
```

效果如下：

![image-20230729014638513](https://s2.loli.net/2023/07/29/YH12P5clNXWrLdU.png)

注意我們上面編寫的列印語句其實是函式的呼叫（後續會進行講解）不能寫到同一行中，否則編譯器會認為是同一句程式碼，同樣會導致編譯不通過：

![image-20230729014909257](https://s2.loli.net/2023/07/29/ja3bzymNF5DEBIh.png)

如果實在要寫到同一行，那麼我們需要在上一句程式碼最後添加`;`來表示上一段的結束：

![image-20230729015012657](https://s2.loli.net/2023/07/29/l4W8UMEviKVo2yp.png)

再比如下面的程式碼：

![image-20230729015512923](https://s2.loli.net/2023/07/29/JNQMTl3m1wvzKiB.png)

這裡我們嘗試在中途換行或是添加空格，因為沒有添加分號，所以說編譯器依然會認為是一行程式碼，因此編譯不會出現錯誤，能夠正常通過。當然，為了程式碼寫得工整和規範，我們一般不會隨意換行或是添加沒必要的空格。注意隨意換行和空格僅限於可分割區域，比如`println`本身是一個函式的完整名稱，這就不能從中間直接斷開，否則語義就完全不一樣了。

### 程式注釋編寫

我們在編寫程式碼時，可能有些時候需要標記一下這段程式碼表示什麼意思：

![image-20230729020246148](https://s2.loli.net/2023/07/29/uQctfFYpomxgBnw.png)

但是如果直接寫上文字的話，會導致編譯不通過，因為這段文字也會被認為是程式的一部分。

這種情況，我們就需要告訴編譯器，這段文字是我們做的筆記，並不是程式的一部分，那麼要怎麼告訴編譯器這不是程式碼呢？很簡單，我們只需要在前面加上雙斜槓就可以了：

![image-20230729020334200](https://s2.loli.net/2023/07/29/TpBZU4XMsYwNJAI.png)

添加雙斜槓之後（自動變成了灰色），後續的文字內容只要沒有發生換行，那麼都會被認為是一段注釋，並不屬於程式，在編譯時會被直接忽略，之後這段注釋也不會存在於程式中。但是一旦發生換行那就不行了：

![image-20230729020416439](https://s2.loli.net/2023/07/29/uKIAkXMl2SR1pWx.png)

那要是此時注釋很多，一行寫不完，我們想要編寫很多行的注釋呢？我們可以使用多行注釋標記：

![image-20230729020514528](https://s2.loli.net/2023/07/29/xIs7PuwMkS16ABD.png)

多行可以使用`/*`和`*/`的組合來囊括需要編寫的注釋內容。

當然還有一種方式就是使用`/**`來進行更加詳細的文件注釋：

![image-20230729020728328](https://s2.loli.net/2023/07/29/AD3oyi6YXs5aOSq.png)

這種注釋可以用來自動生成文件，當我們滑鼠移動到Main上時，會顯示相關的資訊，我們可以自由添加一些特殊的注釋，比如作者、時間等資訊，也可以是普通的文字資訊。

![image-20230729020747000](https://s2.loli.net/2023/07/29/jPENB5caOzIoAHl.png)

這樣，我們編寫Kotlin程式的基本規則就講解完畢了，從下一個小節開始，我們將先給各位小伙伴介紹我們的基本資料類型。

***

## 變數與基本類型

我們的程式不可能永遠都只進行上面那樣的簡單列印操作，有些時候可能需要計算某些資料，此時我們就需要用到變數了。那麼，什麼是變數呢？我們在數學中其實已經學習過變數了：

> 變數，指值可以變的量。變數以非[數字](https://baike.baidu.com/item/數字/6204?fromModule=lemma_inlink)的符號來表達，一般用拉丁字母。變數的用處在於能一般化描述指令的方式。結果只能使用真實的值，指令只能應用於某些情況下。變數能夠作為某特定種類的值中任何一個的保留器。

比如一個公式 x + 2 = 6 此時`x`就是一個變數，變數往往代表著某個值，比如這裡的`x`就代表的是4這個值。在Kotlin中，我們也可以讓變數去代表一個具體的值，並且變數的值是可以發生變化的，在程式中，我們也可以使用變數，並且變數具有類型。

### 電腦中的二進製表示（選學）

進入到變數的學習之前，我們需要先補充一下電腦的底層知識，否則各位小伙伴後面聽起來會很困難。

在電腦中，所有的內容都是二進制形式表示。十進制是以10為進位，如9+1=10；二進制則是滿2進位（因為我們的電腦是電子的，電平訊號只有高位和低位，你也可以暫且理解為通電和不通電，高電位代表1，低電位代表0，由於只有0和1，因此只能使用2進製表示我們的數字！）比如1+1=10=2^1+0，一個位也叫一個bit，8個bit稱為1位元組，16個bit稱為一個字，32個bit稱為一個雙字，64個bit稱為一個四字，我們一般採用位元組來描述資料大小。

注意這裡的bit跟我們生活中的網速MB/s是不一樣的，小b代表的是bit，大B代表的是Byte位元組（8bit = 1Byte位元組），所以說我們辦理寬頻的時候，100Mbps這裡的b是小寫的，所以說實際的網速就是100/8 = 12.5 MB/s了。

> 十進制的7 -> 在二進制中為 111 = 2^2 + 2^1 + 2^0

現在有4個bit位，最大能夠表示多大的數字呢？

- 最小：0000 => 0
- 最大：1111 => 23+22+21+20 => 8 + 4 + 2 + 1 = 15

在Kotlin中，無論是小數還是整數，他們可以帶有符號，因此，首位就作為我們的符號位，還是以4個bit為例，首位現在作為符號位（1代表負數，0代表正數）：

- 最小：1111 => -(22+21+2^0) => -7
- 最大：0111 => +(22+21+2^0) => +7 => 7

現在，我們4bit能夠表示的範圍變為了-7~+7，這樣的表示方式稱為**原始碼**。雖然原始碼表示簡單，但是原始碼在做加減法的時候，很麻煩！以4bit位為例：

> 1+(-1) = 0001 + 1001 = 怎麼讓電腦去計算？（雖然我們知道該去怎麼算，但是電腦不知道！）

我們得創造一種更好的表示方式！於是我們引入了**反碼**：

- 正數的反碼是其本身
- 負數的反碼是在其原始碼的基礎上, 符號位不變，其餘各個位取反

經過上面的定義，我們再來進行加減法：

> 1+(-1) = 0001 + 1110 = 1111 => -0 （直接相加，這樣就簡單多了！）

思考：1111代表-0，0000代表+0，在我們實數的範圍內，0有正負之分嗎？0既不是正數也不是負數，那麼顯然這樣的表示依然不夠合理！根據上面的問題，我們引入了最終的解決方案，那就是**補碼**，定義如下：

- 正數的補碼就是其本身 （不變！）
- 負數的補碼是在其原始碼的基礎上, 符號位不變, 其餘各位取反, 最後+1（即在反碼的基礎上+1，此時1000表示-8）
- 對補碼再求一次補碼就可得該補碼對應的原始碼。

比如-7原始碼為1111，反碼為1000，補碼就是1001了，-6原始碼為1110，反碼為1001，補碼就是1010。所以在補碼下，原本的1000就作為新增的最小值-8存在。

所以現在就已經能夠想通，-0已經被消除了！我們再來看上面的運算：

> 1+(-1) = 0001 + 1111 = (1)0000 => +0 （現在無論你怎麼算，也不會有-0了！）

所以現在，1111代表的不再是-0，而是-1，相應的，由於消除-0，負數多出來一個可以表示的數（1000拿去表示-8了），那麼此時4bit位能夠表示的範圍是：-8~+7（Kotlin使用的就是補碼！）在了解了電腦底層的資料表示形式之後，我們再來學習這些基本資料類型就會很輕鬆了。

### 變數的宣告與使用

要宣告一個變數，我們需要使用以下格式：

```kotlin
var [變數名稱] : [資料類型]
```

這裡的資料類型我們會在下節課開始逐步講解，比如整數就是`Int`類型，不同類型的變數可以儲存不同的類型的值。後面的變數名稱顧名思義，就像`x`一樣，這個名稱我們可以隨便起一個，但是注意要滿足以下要求：

- 標識符可以由大小寫字母、數字、下劃線(_)和美元符號($)組成，但是不能以數字開頭。
- 變數不能重複定義，大小寫敏感，比如A和a就是兩個不同的變數。
- 不能有空格、@、#、+、-、/ 等符號。
- 應該使用有意義的名稱，達到見名知意的目的（一般我們採用英文單字），最好以小寫字母開頭。
- 不可以是 true 和 false。
- 不能與Kotlin語言的關鍵字或是基本資料類型重名

當然各位小伙伴沒必要刻意去進行記憶有哪些關鍵字，我們會在學習的過程中逐步認識到這些關鍵字。新手要辨別一個單字是否為關鍵字，只需要透過IDEA的突顯顏色進行區分即可，比如：

![image-20230729021646779](https://s2.loli.net/2023/07/29/pCmYyvloK1Tsq9A.png)

深色模式下，關鍵字會突顯為橙色，淺色模式下會突顯為深藍色，普通的程式碼都是正常的灰白色。

比如現在我們想要定義一個整數（Int）類型的變數`a`，那麼就可以這樣編寫：

```kotlin
fun main() {
    var a : Int
}
```

但是這個變數一開始沒有任何值，比如現在我們要讓這個變數表示10，那麼就可以將10賦值給這個變數：

```kotlin
fun main() {
    var a : Int = 10
}
```

不過由於變數在一開始就被賦值為10這個整數，此時類型是確定的，Kotlin的編譯器非常聰明，它支援自動推斷類型，這裡會自動將變數a的類型推斷為Int類型，我們可以直接省略掉後面的Int類型：

```kotlin
fun main() {
    var a = 10
}
```

或者我們可以在使用時再對其進行賦值：

```kotlin
fun main() {
    var a : Int
    a = 10
}
```

是不是感覺跟數學差不多？這種寫法對於我們人來說，實際上是很好理解的，意思表達很清晰。為了更直觀地查看變數的值，我們可以直接將變數的值也給列印到控制台：

```kotlin
fun main() {
    var a = 10
    println(a)
}
```

![image-20230729130856235](https://s2.loli.net/2023/07/29/qFHI38zuQWxPACs.png)

變數的值也可以在中途進行修改：

```kotlin
fun main() {
    var a = 666
    a = 777
    println(a)   //這裡列印得到的就是777
}
```

變數的值也可以直接指定為其他變數的值：

```kotlin
fun main() {
    var a = 10
    var b = a //直接讓b等於a，那麼a的值就會給到b
    println(b) //這裡輸出的就是10了
}
```

我們還可以讓變數與數值之間做加減法（運算符會在後面詳細介紹）：

```kotlin
fun main() {
    var a = 9   //a初始值為9
    a = a + 1   //a = a + 1也就是將a+1的結果賦值給a，跟數學是一樣的，很好理解對吧
    println(a)  //最後得到的結果就是10了
}
```

對於那些唯讀的變數，我們可以將其表示為一個常量，使用`val`關鍵字：

```kotlin
fun main() {
    val a = 666 //使用val關鍵字，表示這是一個常量
    a = 777;    //常量的值不允許發生修改
}
```

編譯時得到報錯：

![image-20230729142023779](https://s2.loli.net/2023/07/29/A2u3yx69GbZmStJ.png)

常量的值只有第一次賦值可以修改，其他任何情況下都不行：

```kotlin
fun main() {
    val a: Int
    a = 777;
}
```

至此，宣告變數和常量我們就介紹完畢了，下一部分我們將介紹常見的一些資料類型。

### 數字類型介紹

前面我們了解了如何建立變數，並進行使用，但是我們知道，不同的資料往往對應著不同的類型，比如整數我們使用的就是Int，而這一部分我們將學習更多的基本資料類型。

Kotlin提供了一組表示數字的內建類型，對於整數，有四種不同大小的類型，因此，值範圍：

| 類型  | 大小（位） | 最小值                             | 最大值                                |
| ----- | ---------- | ---------------------------------- | ------------------------------------- |
| Byte  | 8          | -128                               | 127                                   |
| Short | 16         | -32768                             | 32767                                 |
| Int   | 32         | -2,147,483,648 (-2^31)             | 2,147,483,647（2^31-1）               |
| Long  | 64         | -9,223,372,036,854,775,808 (-2^63) | 9,223,372,036,854,775,807（2^63 - 1） |

為什麼不同的資料類型有著值範圍呢？這是因為我們的電腦底層是採用0和1表示資料的，並且資料的表示位數有限，我們以二進制來計算，就像下面這樣：

> 1 + 1 = 10 
>
> 可能很多小伙伴會好奇，為什麼1 + 1得到的結果是數字十？這是因為二進制中只有0和1，因此只要滿二就進一，所以就變成這樣的結果了，如果各位是初次學習，可能會不太好理解。

這裡以上面的8位大小的Byte類型為例，在電腦底層儲存資料時，只有8個bit位（一個bit位就可以表示一個0或1）來儲存它，那麼它能表示的最大值和最小值就是：

> 00000000 ~ 11111111   轉換為十進制就是   0 ~ 255

不過為了能夠表示負數，電腦一般使用補碼進行表示，所以，上面的最小值和最大值就變成了-128 ~ 127了。

預設情況下，我們使用的常量數字都是Int類型，除非它的大小已經超出Int類型能夠表示的最大範圍，在超出Int類型可以表示的最大範圍之後，預設為Long類型：

```kotlin
val one = 1 // Int
val threeBillion = 3000000000 // Long
val oneLong = 1L // 我們也可以在數字後面添加大寫字母L來表示這是一個Long類型的數值
val oneByte: Byte = 1   //Int類型資料也可以在符合其他類型範圍時自動轉換
```

對於一些比較長的數字，我們可能需要使用類似於分隔符號一類的東西來方便我們計數，比如：

> 銀行往往把1000000000這種長數字記為1,000,000,000，這樣看起來會更直觀

在Kotlin中也可以像這樣去編寫：

```kotlin
val a = 1_000_000_000
```

數字類型不僅可以寫成十進制，也可以以十六進制或是二進製表示（Kotlin不支援八進製表示）只需要添加對應的前綴即可，比如一個十六進制資料：

```kotlin
val a = 0xAF
```

因為十六進制中大於等於十的資料沒有對應的阿拉伯數字可以表示，所以在電腦中就以ABCDEF來替代這無法表示的6個數字。並且我們需要在數字前面添加0x表示這是16進制的數字，接下來是2進制：

```kotlin
val a = 0b1001   //0b前綴表示二進制資料，後面的1010對應著十進制的9
```

除了整數類型外，Kotlin還為無符號整數提供以下類型：

- `UByte`：一個無符號8位整數，範圍從0到255
- `UShort`：無符號16位整數，範圍從0到65535
- `UInt`：一個無符號32位整數，範圍從0到2^32 - 1
- `ULong`：一個無符號64位整數，範圍從0到2^64 - 1

為了使無符號整數更易於使用，Kotlin同樣提供了用後綴標記，該後綴表示無符號類型（類似於上面的`Long`類型添加L字母）

- 使用`u`或`U`字母作為後綴表示無符號整數。而具體的類型是根據前面變數的類型確定的，如果變數沒有提供類型，編譯器將根據數字的大小使用`UInt`或`ULong`：

  ```kotlin
  val b: UByte = 1u  // UByte類型, 由變數提供的類型
  val s: UShort = 1u // UShort類型, 由變數提供的類型
  val l: ULong = 1u  // ULong類型, 由變數提供的類型
  
  val a1 = 42u    // UInt類型，根據數字大小自動推斷得到
  val a2 = 0xFFFF_FFFF_FFFFu // ULong類型，根據數字大小自動推斷得到
  ```

- `uL`和`UL`可以將文字直接標記為無符號Long類型：

  ```kotlin
  val a = 1UL // ULong類型，直接使用後綴標記
  ```

對於小數來說，Kotlin提供符合IEEE [754標準的](https://en.wikipedia.org/wiki/IEEE_754)浮點類型`Float`和`Double`，`Float`為IEEE 754標準中的單精度資料，而`Double位標準中的雙精度資料，對於單雙精度，本質上就是能夠表示的小數位精度，雙精度比單精度的小數精度更高。

這些類型的大小不同，並為不同精度的浮點數提供儲存：

| 類型     | 大小（位） | 符號與尾數位數 | 階碼位數 | 小數位數 |
| -------- | ---------- | -------------- | -------- | -------- |
| `Float`  | 32         | 24             | 8        | 6-7      |
| `Double` | 64         | 53             | 11       | 15-16    |

我們也可以直接建立小數類型的`Double`和`Float`變數，小數部分與整數部分由一個小數點（`.`）隔開，編譯器預設情況下會將所有的小數自動推斷為推斷`Double`類型：

```kotlin
val pi = 3.1415 // 預設推斷為Double類型
val one: Double = 1 // 這種寫法是錯誤的，因為1不是小數，無法編譯透過
val one: Double = 1.0 // 但是這種寫法就是對的，因為這樣表示就是小數，即使小數位是0
```

由於預設是Double類型，如果我們要明確指定值為`Float`類型，那麼需要添加後綴`f`或`F`，並且由於精度問題，如果該值包含超過6-7位小數，則會遺失一部分精度：

```kotlin
val e = 2.7182818284 // Double類型的數值
val e: Float = 2.7182818284f // 這裡表示為Float會導致精度折損，得到2.7182817
```

與其他一些語言不同，Kotlin中的數字類型沒有隱式轉換的操作，例如，一個`Double`類型的變數無法將其值賦值給`Int`類型變數：

![image-20230729211441090](https://s2.loli.net/2023/07/29/zwiQaU81LsIujr4.png)

如果需要將一個整數轉換為小數，我們會在後面學習函式之後再給各位小伙伴講解如何呼叫函式進行顯示類型轉換。

### 數字類型的運算

Kotlin支援數學上標準的算術運算集，例如：`+`，`-`，`*`，`/`，`%` 並且這些運算符都是透過運算符重載實現的具體功能，我們會在後續的章節中講解Kotlin的運算符重載機制，這裡各位小伙伴就當做是普通的運算操作即可。

> Kotlin支援運算符重載，運算符重載是一種允許程式設計師重新定義運算符的語言特性，透過運算符重載，您可以為自訂的類或資料類型定義一些特定操作的行為。

其中加減乘除操作這裡就不做介紹了，而%符號用於取餘操作，也就是計算前面的數整除後面的數得到的餘數：

```kotlin
println(1 + 2)   //計算1加上2的結果
println(2_500_000_000L - 1L)   //計算2500000000減去1的結果
println(3.14 * 2.71)   //計算3.14與2.71的乘積
println(10.0 / 3)   //計算10除以3得到的結果
println(10 / 3)   //10除以3得到的餘數為1
```

以上運算都比較簡單，但是注意在除法運算中，只有兩個運算元中出現小數，除法的結果才是小數，如果兩個運算元都是整數，那麼得到的結果也是整數，並且直接遺失小數位（不會四捨五入）

```kotlin
println(5 / 2)    //結果是2，而不是2.5
```

同樣的，除了直接使用字面量來進行運算，我們也可以將定義的變數參與到運算中：

```kotlin
fun main() {
    val a = 10
    println(a / 2)
}
```

注意，在Kotlin中不同的算數運算符，它們的優先度也不一樣：

```kotlin
println(1 + 2 * 3)
```

在數學中，乘法運算的優先度比加法運算更高，因此我們需要先計算乘法，再計算加法，而在Kotlin中是一樣的，乘法和除法運算符的優先度是高於加法運算符的，所以說上面算出來的結果是7，同樣的，我們數學中使用括號來提升某些運算的優先度，在Kotlin中同樣可以，比如：

```kotlin
println((1 + 1) * 3)   //使用小括號來強制提升優先度
```

有些時候，我們可能想要讓某個變數的值增加一定數值，比如下面這樣：

```kotlin
var a = 10
a = a + 9   //讓a等於a+9的結果
```

對於這種讓變數本身加減乘除某個值的情況，可以使用賦值運算符簡化：

```kotlin
a += 9   //等價於 a = a + 9
a /= 9   //等價於 a = a / 9
a %= 2   //等價於 a = a % 2
```

如果我們只是希望某個變數自增或自減1，那麼我們可以像這樣去寫：

```kotlin
fun main() {
    var a = 10
    a++    //使用兩個++表示自增1
    println(a)     //列印得到11
  	a--    //使用兩個--表示自減1
}
```

不過，這個雙++符號，可以放在變數的前後，都能實現自增操作：

```kotlin
var a = 10
++a   //最終效果等價於a++
```

但是他們有一個本質區別，就是++在前面，a是先自增再得到結果，而++在後面，是a先得到結果，再進行自增，比如：

```kotlin
fun main() {
    var a = 10
    println(a++)   //這裡++在後面，列印a的值依然是10，但是結束之後a的值就變成11了
    println(++a)   //這裡++在前面，列印a的值是這裡先自增之後的結果，就是12了
}
```

對於新手來說，這個很容易搞混，所以說一定要記清楚。

Kotlin提供了一組整數的*位運算*操作，可以直接在二進制層面上與數字表示的位進行操作，不過只適用於`Int`和`Long`類型的資料：

- `shl(bits)`– 有符號左移
- `shr(bits)`– 有符號右移
- `ushr(bits)`– 無符號右移
- `and(bits)`– 按位與
- `or(bits)`– 按位或
- `xor(bits)`– 按位異或
- `inv()`– 取反

這裡我們從按位與開始講解，比如下面的兩個數：

```kotlin
fun main() {
    val a = 9
    val b = 3
    val c = a and b //進行按位與運算
    println(c)
}
```

按位與實際上就是讓這兩個數每一位都進行比較，如果這一位兩個數都是1，那麼結果就是1，否則就是0：

- a = 9 = 1001
- b = 3 = 0011
- c = 1 = 0001（因為只有最後一位，兩個數都是1，所以說結果最後一位是1，其他都是0）

同樣的，按位或，其實就是只要任意一個為1（不能同時為0）那麼結果就是1：

```kotlin
fun main() {
    val a = 9
    val b = 3
    val c = a or b
    println(c)
}
```

- a = 9 = 1001
- b = 3 = 0011
- c =11= 1011（只要上下有一個是1或者都是1，那結果就是1）

按位異或的意思就是只有兩邊不相同的情況下，結果才是1，也就是說一邊是1一邊是0的情況：

- a = 9 = 1001
- b = 3 = 0011
- c =10= 1010（從左往右第二位、第四位要嘛兩個都是0，要嘛兩個都是1，所以說結果為0）

按位取反操作跟前面的正負號一樣，只操作一個數，最好理解，如果這一位上是1，變成0，如果是0，變成1：

- 127 = 01111111
- -128 = 10000000

所以說計算的結果就是-128了。

除了以上的四個運算符之外，還有位移運算符，比如：

```kotlin
fun main() {
    val c = 1 shl 2 //shl表示左移運算
    println(c)
}
```

- 1 = 00000001
- 4 = 00000100（左移兩位之後，1跑到前面去了，尾部使用**0**填充，此時就是4）

我們發現，左移操作每進行一次，結果就會x2，所以說，除了直接使用`*`進行乘2的運算之外，我們也可以使用左移操作來完成。

同樣的，右移操作就是向右移動每一位囉：

```kotlin
fun main() {
    val c = 8 shr 2  //shr表示右移運算
    println(c)
}
```

跟上面一樣，右移操作可以快速進行除以2的計算。對於負數來說，左移和右移操作不會改變其符號位上的數字，符號位不受位移操作影響：

```kotlin
fun main() {
    val c = -8 shr 2   //這裡得到的依然是個負數
    println(c)
}
```

我們也可以使用考慮符號位的右移操作，一旦考慮符號位，那麼符號會被移動：

```kotlin
fun main() {
    val c = -1 ushr 1 //無符號右移是ushr，移動會直接考慮符號位
    println(c)
}
```

比如：

- -1 = 11111111 11111111 11111111 11111111
- 右移： 01111111 11111111 11111111 11111111（無符號右移使用0填充高位）

此時得到的結果就是正數的最大值 2147483647 了，注意，不存在無符號左移操作。

最後我們再總結一下不同運算符的優先度，對應的優先度從上往下依次減弱：

1. 一元運算符：例如 ++、--、+、-、!、~
2. 乘法和除法運算符：*、/、%
3. 加法和減法運算符：+、-
4. 位移運算符：shl、shr、ushr
5. 按位與運算符：and
6. 按位或運算符：or
7. 按位異或運算符：xor
8. 邏輯運算符：&&、||
9. 比較運算符：>、>=、<、<=、==、!=
10. 區間運算符：..
11. 賦值運算符：=、+=、-=、*=、/=、%=

當然，這裡列出的部分運算符各位小伙伴可能還沒有遇到，不過在後續的學習中，我們會慢慢認識的，屆時各位小伙伴可以回顧一下這裡。

### 布爾類型介紹

布爾類型是Kotlin中的一個比較特殊的類型，它並不是存放數字的，而是狀態，它有下面的兩個狀態：

- true - 真
- false - 假

布爾類型（boolean）只有`true`和`false`兩種值，也就是要嘛為真，要嘛為假，布爾類型的變數通常用作流程控制判斷語句（不同於C語言，C語言中一般使用0表示false，除0以外的所有數都表示true）

```kotlin
val a: Boolean = true
```

如果給一個其他的值，會無法編譯通過：

![image-20230729214712431](https://s2.loli.net/2023/07/29/hMkCfA6DVpWTPIi.png)

布林值除了可以直接賦值得到，也可以透過一些關係運算得到，常見的關係運算有大於、小於以及等於，所有的關係運算在下方：

- 判斷兩個數是否相等：`a == b`和`a != b`
- 判斷數之間大小：`a < b`，`a > b`，`a <= b`，`a >= b`
- 判斷數是否在指定範圍中：`a..b`，`x in a..b`，`x !in a..b`

比如我們想判斷變數a和變數b的值是否相同：

```kotlin
fun main() {
    val a = 10
    val b = 8
    println(a == b)  //判斷a是否等於b（注意等號要寫兩個，因為單等號為賦值運算）
    println(a >= b)   //判斷a是否大於等於b
    println(a < b)   //判斷a是否小於b
  	val c: Boolean = a != b   //判斷a是否不等於b並將結果賦值給變數c
}
```

可以看到，透過邏輯運算得到的結果，都是true或false，也就是我們這裡學習的Boolean類型值。在Kotlin中，我們為了快速判斷某個數是否在一個區間內，可以直接使用 `a..b` 來表示一個數學上`[a, b]`這樣的閉區間，比如我們這裡要判斷變數`a`的值是否在1~10之間：

```kotlin
fun main() {
    val a = 10
    println(a in 1..10)   //這裡1..10表示1~10這個閉區間，使用in關鍵字來進行判斷
  	println(a in 1..<10)   //這裡1..<10表示1~10這個前閉後開區間，使用in關鍵字來進行判斷
  	println(a !in 1..10)   //相反的，使用!in判斷是否不在這個區間
}
```

對於Boolean類型的變數之間，也有一些邏輯運算符用於進行組合條件判斷：

- `||`– 邏輯或運算
- `&&`– 邏輯與運算
- `!`– 取反運算

其中取反運算最好理解，它可以讓true變成false，false變為true，比如：

```kotlin
fun main() {
    val a = 10
    val b = 20
    val c = a > b   //這裡很明顯c應該為false
    println(!c)   //這裡進行了取反操作並列印，那麼結果就是true了
}
```

對於邏輯與和邏輯或運算，我們可以像這樣去使用：

```kotlin
fun main() {
    val a = 10
    val b = 0
    println(100 >= a && b >= 60)  //我們可以使用與運算符連接兩個判斷表達式，只有兩邊都為true結果才是true
    println(100 >= a || b >= 60)  //我們可以使用或運算符連接兩個判斷表達式，只要兩邊任意一個為true結果就是true
}
```

與運算符要求左右兩邊同時為真，得到的結果才是真，否則一律為假，而或運算就是要求兩邊只要有一邊為真，結果就是真，除非兩邊同時為false，那麼就沒戲唱了。

不過需要注意的是，在與運算中，第一個判斷表達式得到了`false`之後，此時不會再繼續執行第二個表達式，而是直接得到結果`false`（邏輯運算符會出現短路的情況，只要第一個不是真，就算第二個是真也不可能了，所以說為了效率，後續就不用再判斷了，在使用時一定要注意這一點）同樣的，或運算下當發現第一個判斷表達式為true時，也不會繼續向後執行了，因為結果已經是頂真了。

### 字元類型介紹

字元類型也是一個重要的基本資料類型，它可以表示電腦中的任意一個字元（包括中文、英文、標點等一切可以顯示出來的字元）字元由`Char`類型表示，字元值用單引號：`'1'`囊括：

```kotlin
val c: Char = 'A'
println(c)
```

注意，字元只能表示一單個字元，我們之前遇到的字串跟字元不一樣，關於字串我們會在下節課進行介紹。

我們列印出來的也是單個字元：

![image-20230729233735560](https://s2.loli.net/2023/07/29/lS12kDwfR9TrO4b.png)

那麼可能會有小伙伴好奇，字元類型在電腦底層是怎麼進行儲存的呢？實際上每個字元在電腦中都會對應一個字元碼，首先我們需要介紹ASCII碼：

![img](https://s2.loli.net/2022/09/17/Z7AiBPNO6ylML4z.png)

比如我們的英文字母`A`要展示出來，那就是一個字元的形式，而其對應的ASCII碼值為65，我們可以使用`.code`來獲取某個字元對應的ASCII碼，比如下面這樣：

```kotlin
fun main() {
    val c: Char = 'A'
    println(c.code)   //這裡就會列印字元對應的ASCII碼
}
```

得到結果為：

![image-20230729233949424](https://s2.loli.net/2023/07/29/a4ZRYXcK5E7d1MP.png)

字元型占據2個位元組的空間用於存放資料：

- char 字元型（16個bit，也就是2位元組，它不帶符號）範圍是0 ~ 65535

不過，這裡的字元表裡面不就128個字元嗎，那`char`幹嘛要兩個位元組的空間來存放呢？我們發現表中的字元遠遠沒有我們所需要的那麼多，這裡只包含了一些基礎的字元，中文呢？那麼多中文字元（差不多有6000多個），用ASCII編碼表那128個肯定是沒辦法全部表示的，但是我們現在需要在電腦中使用中文，這時，我們就需要擴展字元集了。

> Unicode是一個用於表示文字字元的標準字元集。它包含了世界上幾乎所有的已知字元，包括不同國家和地區的字母、數字、標點符號、符號圖形以及特殊的控制字元。
>
> 與Unicode不同，ASCII（American Standard Code for Information Interchange）是一個只包含128個字元的字元集。它最初是為了在電腦系統中傳輸基本英語字元而設計的。ASCII字元集包含了常見的拉丁字母、數字、標點符號以及一些特殊字元。
>
> Unicode採用了一個更加廣泛的字元編碼方案，包括了不同的字元集編碼，比如UTF-8和UTF-16等。UTF-8是一種可變長度的編碼方案，它可以用來表示Unicode中的任意字元，且向後相容ASCII字元集。而UTF-16則是一種固定長度的編碼方案，它使用兩個位元組來表示一個Unicode字元。
>
> 與ASCII相比，Unicode的主要優勢在於它能夠表示各種不同的語言和字元，而不僅僅限於英語字元。這使得Unicode成為全球通用的字元編碼標準，為不同國家和地區的語言提供了統一的編碼方式。

所以，一個Char就能表示幾乎所有國家語言的字元，這樣就很方便了。

接著我們來介紹一下轉譯字元，對於一些我們平時很難直接透過鍵盤或是輸入法打出來的字元，比如一些特殊符號：

![image-20230730000657951](https://s2.loli.net/2023/07/30/ugem2scKxyX7wJL.png)

這些符號我們沒辦法直接打出來，但是現在我們又想要表示它們，該怎麼做呢？我們可以使用轉義來將這些字元對應的Unicode編碼轉換為對應的字元，只需要在前面加上`\u`即可，比如✓這個符號：

```kotlin
fun main() {
    val c = '\u2713'   //符號✓對應的Unicode編碼為10003，這裡需要轉換為16進製表示，結果為0x2713
    println(c)
}
```

除了能像這樣表示一個特殊字元，我們也可以使用一些其他的跳脫字元來表示各種東西：

- `\t` – 頁籤
- `\b` – 退格
- `\n` – 換行（LF）
- `\r` – Enter（CR）
- `\'` – 單引號
- `\"` – 雙引號
- `\\` –反斜線
- `\$` – 美元符號

這些跳脫字元都是為了防止在特殊情況下無法表示某些字元，而給我們的替代方案，後續各位小伙伴在使用時可以回來參考一下。

### 字串類型介紹

字串類是一個比較特殊的類型，它用於儲存字串。我們知道，基本類型`Char`可以儲存一個2位元組的Unicode字元，而字串則是一系列字元的序列，它的類型名稱為`String`。

字串通常由雙引號`""`囊括，它可以表示一整串字元：

```kotlin
val str: String = "Hello World"
```

注意，字串中的字元一旦確定，無法進行修改，只能重新建立。

如果我們需要再字串中換行，需要用到跳脫字元，字串中同樣支援使用跳脫字元：

```kotlin
fun main() {
    val text = "Hello\nWorld"
    println(text)
}
```

不過，字串只能寫一行，有時候有點不太夠用，可能我們想要列印多行文字，我們除了用`\n`跳脫字元來換行之外，也可以直接使用三個雙引號`"""`來表示一個原始字串，但是原始字串無法使用跳脫字元：

```kotlin
fun main() {
    val text = """
    這是第一行
    這第二行
    別\n了，沒用
    真厲害啊，這功能隔壁Java15才有
    """
    println(text)
}
```

效果如下：

![image-20230730002653406](https://s2.loli.net/2023/07/30/Y5fbh8FEOZcsMVz.png)

可以看到確實是夠原始的，把我程式碼裡面的縮排都給列印出來了，這樣肯定不是我們希望的樣子，我們希望的僅僅是一個簡單換行而已，那這裡該怎麼去處理呢？後面我們在講解函式之後，會額外補充這裡的內容。

有時候為了方便，我們可以將不同的字串拼接使用：

```kotlin
fun main() {
    val str1 = "Hello"
    val str2 = "World"
    val str = str1 + str2
    println(str)   //使用 + 來拼接兩個字串，得到的結果就是兩個字串合在一起的結果
}
```

字串除了和字串拼接之外，也可以和其他類型進行拼接：

```kotlin
fun main() {
    val a = 10
    val text = "這是拼接的值" + a
    println(text)   //列印出來就是與其他類型的拼接結果
}
```

但是我們需要注意字串拼接的順序，只能由字串拼接其他類型，如果是其他類型拼接字串，可能會出現問題：

![image-20230730003158613](https://s2.loli.net/2023/07/30/AZSxuKqRvMohp8I.png)

但是現在我們就是希望其他類型的資料拼在最前面，這裡應該怎麼做呢？我們可以使用字串模版來完成：

```kotlin
fun main() {
    val a = 10
    val text = "這是拼接的值$a"  //這裡的$為模版表達式，可以直接將後面跟著的變數或表達式以字串形式取代到這個位置
    println(text)
}
```

如果要添加到前面：

```kotlin
val text = "$a 這是拼接的值" //注意這裡$a之後必須空格，否則會把後面的整個字串認為這個變數的名字
```

出現這種情況除了用空格去解決之外，我們也可以添加一個花括號：

```kotlin
val text = "${a}這是拼接的值"  //添加花括號就可以消除歧義了
val text = "${a > 0}這是拼接的值"  //花括號中也可以寫成表達式
```

由於美元符用於模版表達式了，所以說如果我們希望在字串中僅僅表示$這個字元，那麼我們需要用到轉義：

```kotlin
val text = "\$這是美元符"   //普通字串直接使用\$表示
//原始字串要套個娃
val str = """
  ${'$'}這是美元符    
	"""
```

至此，關於Kotlin的變數與基本類型的內容我們就暫時告一段落了，不過在後面學習了更多知識後，我們還會回顧這些基本類型，了解他們的更多用法，並且認識我們唯一沒有在這一部分介紹的陣列類型。

***

## 流程控制

經過前面的學習，我們知道，程式都是從上往下依次執行的，但是，僅僅是這樣還不夠，我們需要更加進階的控制語句來使得程式更加有趣。比如，判斷一個整數變數，大於1則輸出yes，小於1則輸出no，這時我們就需要用到選擇結構來幫助我們完成條件的判斷和程式的分支走向。

在前面我們介紹了運算符，我們可以透過邏輯運算符和關係運算符對某些條件進行判斷，並得到真或是假的結果。這一部分我們將繼續使用這些運算符進行各種判斷，以及實現流程控制。

### 選擇結構（if-else）

某些時候，我們希望進行判斷，只有在條件為真時，才執行某些程式碼，這種情況就需要使用到選擇分支語句，首先我們來認識一下`if`語句：

```kotlin
if (條件判斷) 判斷成功執行的程式碼;
```

`if`的小括號中需要我們傳入一個Boolean類型的結果，可以是一個Boolean變數，也可以是一個判斷語句，反正只能接受true和false兩種結果，比如下面的這個例子：

```kotlin
fun main() {
    val a = 10
    if(a == 12)  //只有當a判斷等於12時，才會執行下面的列印語句
        println("Hello World!")
    println("我是後續的語句")  //if只會對緊跟著的一行程式碼生效，後續的內容無效
}
```

`if`會進行判斷，只有判斷成功時才會執行緊跟著的語句，否則會直接跳過，注意，如果我們想要在if中執行多行程式碼，需要使用程式碼塊將這些程式碼囊括起來（實際上程式碼塊就是將多條語句複合到一起，使用花括號囊括）所以說，我們以後使用if時，如果分支中有多行程式碼需要執行，就需要添加花括號，如果只有一行程式碼，花括號可以直接省略，包括我們後面會講到的else、while、for語句都是這樣的，就像下面這樣：

```kotlin
fun main() {
    val a = 15
    if (a > 10) {    //只有判斷成功時，才會執行下面的程式碼塊中內容，否則直接跳過
        println("a大於10")
        println("a的值為：$a")
    }
    println("我是外層")
}
```

如果我們希望判斷條件為真時執行某些程式碼，條件為假時執行另一些程式碼，我們可以在後面繼續添加else語句：

```kotlin
fun main() {
    val a = 15
    if (a > 10) {    //只有判斷成功時，才會執行下面的程式碼塊中內容，否則直接跳過
        println("a大於10")
        println("a的值為：$a")
    } else {   //當判斷不成功時，會執行else程式碼塊中的程式碼
        println("a小於10")
        println("a的值為：$a")
    }
    println("我是外層")
}
```

`if-else`語句就像兩個分支，跟據不同的判斷情況從而決定下一步該做什麼，這跟我們之前認識的三元運算符性質比較類似。

那如果此時我們需要判斷多個分支呢？比如我們現在希望判斷學生的成績，不同分數段列印的等級不一樣，比如90以上就是優秀，70以上就是良好，60以上是及格，其他的都是不及格，那麼這種我們又該如何判斷呢？要像這樣進行連續判斷，我們需要使用`else-if`來完成：

```kotlin
fun main() {
    val score = 2
    if (score >= 90) //90分以上才是優秀
        println("優秀") 
    else if (score >= 70) //當上一級if判斷失敗時，會繼續判斷這一級
        println("良好") 
    else if (score >= 60) 
        println("及格") 
    else  //當之前所有的if都判斷失敗時，才會進入到最後的else語句中
        println("不及格")
}
```

當然，`if`分支語句還支援嵌套使用，比如我們現在希望低於60分的同學需要補習，0-30分需要補Java，30-60分需要補C++，這時我們就需要用到嵌套：

```kotlin
fun main() {
    val score = 2
    if (score < 60) {   //先判斷不及格
        if (score > 30) //在內層再嵌套一個if語句進行進一步的判斷
            println("學習C++") 
        else 
            println("學習Java")
    }
}
```

除了if自己可以進行嵌套使用之外，其他流程控制語句同樣可以嵌套使用，也可以與其他流程控制語句混合嵌套使用。這樣，我們就可以靈活地使用`if`來進行各種條件判斷了。

除了直接執行語句之外，我們也可以將if和else用作結果判斷，比如：

```kotlin
fun main() {
    val score = 2
  	//這裡判斷socre是否大於60，是就得到Yes，否就得到No，並且可以直接賦值給變數
    val res = if (score > 60) "Yes" else "No"
}
```

這類似於其他語言，如Java和C中的三元運算，不過Kotlin中沒有那樣的三元運算符，只能使用上面的表達式，對於多行程式碼塊的情況，預設最後一行作為返回的結果：

```kotlin
fun main() {
    val score = 2
    val res = if (score > 60) {
        println("不錯啊期末沒被當")
        "Yes"   //程式碼塊預設最後一行作為返回結果
    } else {
        println("不會有人Java期末還要被當吧")
        "No"
    }
}
```

注意，如果需要這種返回結果的表達式，那麼必須要存在`else`分支，否則不滿足條件豈不是沒結果了？

### 選擇結構（when）

前面我們介紹了if語句，我們可以透過一個if語句輕鬆地進行條件判斷，然後根據對應的條件，來執行不同的邏輯，當然除了這種方式之外，我們也可以使用`when`語句來實現，它更適用於多分支的情況：

`when`定義具有多個分支的條件表達式。它類似於類似Java和C語言中的`switch`語句，它簡單的形式看起來像這樣：

```kotlin
when (目標) {
    匹配值1 -> 程式碼...   //我們需要傳入一個目標，比如變數，或是計算表達式等
    匹配值2 -> 程式碼...   //如果目標的值等於我們這裡給定的匹配值，那麼就執行case後面的程式碼
    else -> {
        程式碼...    //如果以上條件都不滿足，就進入else中（可以沒有），類似於之前的if-elseif-else
    }
}
```

比如現在我們要根據學生的等級進行分班，學生有ABC三個等級：

```kotlin
fun main() {
    val c = 'A'
    when (c) {
        'A' -> println("去資優班！準備衝刺985大學！")
        'B' -> println("去平行班！準備衝刺一本！")
        'C' -> println("去職高深造。")
    }
}
```

如果將when用作表達式，則else分支必須存在，除非編譯器能推斷出所有可能的情況都包含分支條件，比如下面的例子：

```kotlin
fun main() {
    val c = 'A'
    val numericValue = when (c) {
        'B' -> 0
        'A' -> 1
        else -> 2    //還有其他情況，這裡必須添加else，不然其他情況豈不是沒返回的東西？
    }
}
```

以下情況就可以不需要else語句：

```kotlin
fun main() {
    val c = true
    val numericValue = when (c) {
        false -> 0
        true -> 1
        // 由於Boolean只具備真和假條件，這裡的'else' 就不再強制要求
      	// 這同樣適用於比如列舉類等
    }
}
```

在`when`*語句*中，遇到以下情況，攜帶`else`分支是必須的：

- `when`分支中僅有一個`Boolean`類型、列舉 或 密封，以及用於判斷的目標變數是可空的情況（後面會講解）
- `when`分支沒有包括該判斷目標的所有可能的值。

有時候我們可能希望某些值都屬於同一個情況，可以使用逗號將其條件組合成一行：

```kotlin
when (x) {
    0, 1 -> print("x == 0 or x == 1")
    else -> print("otherwise")
}
```

我們也可以使用任意表達式（不僅僅是常量）作為分支條件，比如之前的if-else案例中我們判斷學生成績：

```kotlin
fun main() {
    val score = 10
    val grade = when(score) {
      	//使用in判斷目標變數值是否在指定範圍內
        in 100..90 -> "優秀"
        in 89..80 -> "良好"
        in 79..70 -> "及格"
        in 69..60 -> "厲害"
        else -> "不及格"
    }
}
```

包括我們之後學習的類型判斷`is`表達式、函式呼叫等，都可以在這裡作為分支條件。

### 循環結構（for）

通過前面的學習，我們了解了如何使用分支語句來根據不同的條件執行不同的程式碼，我們接著來看第二種重要的流程控制語句：循環語句。

我們在某些時候，可能需要批次執行某些程式碼：

```kotlin
fun main() {
    println("大煙杆嘴裡塞，我只抽第五代")   //把這句話給我列印三遍
    println("大煙杆嘴裡塞，我只抽第五代")
    println("大煙杆嘴裡塞，我只抽第五代")
}
```

遇到這種情況，我們由於還沒學習循環語句，那麼就只能寫N次來實現這樣的多次執行。但是如果此時要求我們將一句話列印100遍、1000遍、10000遍，那麼我們豈不是光CV程式碼就要搞一下午？

現在，要解決這種問題，我們可以使用for循環語句來多次執行：

```kotlin
for (遍歷出來的單個目標變數 in 可遍歷目標) 循環體
```

這裡的可遍歷目標有很多，比如：

* 陣列
* 區間
* 任何實現了運算符重載函式iterator的類

這裡我們只學習了區間，我們來看看如何使用，比如我們要列印一段話3遍：

```kotlin
fun main() {
    for (i in 1..3)  //這裡直接寫入1..3表示1~3這個區間
        println("大煙杆嘴裡塞，我只抽第五代：$i")
}
```

列印結果為：

![image-20231216151835790](https://s2.loli.net/2023/12/16/5XuaWMjw3YDxvlK.png)

可以看到，每一次遍歷出來的變數`i`，其實就是每次遍歷的下一個目標，比如這裡是1..3的區間，那麼得到的依次就是1、2、3這三個結果了，唯一需要注意的是，這裡的`i`是局部的，只在`for`循環內部可用（包括嵌套的內部）並不是整個main中都可以使用：

![image-20230730160547655](https://s2.loli.net/2023/07/30/mCGVySxMK2YLfkJ.png)

預設情況下，每一輪循環都會向後+1，我們也可以自由控制每一輪增加多少，也就是步長：

```kotlin
fun main() {
    for (i in 1..10 step 2) {
        println(i)
    }
}
```

這樣，列印出來的資料會按照步長進行增長：

![image-20230801014238248](https://s2.loli.net/2023/08/01/vpHO32fU4SL1qYM.png)

那如果我們需要從10到1倒著進行遍歷呢？我們可以將`..`取代為`downTo`來使用：

```kotlin
fun main() {
    for (i in 10 downTo 1) {
        println(i)   //這裡得到的就是10到1倒著排列的範圍了
    }
}
```

我們可以使用除錯來觀察每一輪的變化，除錯模式跟普通的執行一樣，也會執行我們的Java程式，但是我們可以添加斷點，也就是說當程式碼執行到斷點位置時，會在這裡暫停，我們可以觀察當程式碼執行到這個位置時各個變數的值：

![image-20230730152627331](https://s2.loli.net/2023/07/30/CbXHzwlAIa5uo8e.png)

除錯模式在我們後面的學習中非常重要，影響深遠，所以說各位小伙伴一定要學會。除錯也很簡單，我們只需要點擊右上角的除錯選項即可（圖示像一個小蟲子一樣，因為除錯的英文名稱是Debug）

![image-20230730152438291](https://s2.loli.net/2023/07/30/BF28HR7LxsISqjP.png)

除錯開始時，我們可以看到程式在斷點位置暫停了：

![image-20230730152411984](https://s2.loli.net/2023/07/30/lIoGQnrC6LWE7mw.png)

此時我們可以觀察到目前的變數`i`的值，也可以直接在下方的除錯視窗中查看：

![image-20230730152653140](https://s2.loli.net/2023/07/30/34xZXWVPv8qfH9C.png)

隨著循環的進行，i的值也會逐漸自增。

和之前的`if`一樣，for循環同樣支援嵌套使用：

```kotlin
fun main() {
    for (i in 0..2)  //外層循環執行3次
        for (j in 0..2)  //內層循環也執行3次
            println("外層$i，內層$j")
}
```

上面的程式碼中，外層循環會執行3輪，而整個循環體又是一個循環語句，那麼也就是說，每一輪循環都會執行裡面的整個循環，裡面的整個循環會執行3，那麼總共就會執行3 x 3次，也就是9次列印語句。

我們也可以在循環過程中提前終止或是加速循環的進行，這裡我們需要認識兩個新的關鍵字：

```kotlin
for (i in 0..2) {
    if (i == 1) continue  //比如我們希望當i等於1時跳過這一輪，不執行後面的列印
    println("在這麼冷的天")
    println("目前i的值為：$i")
}
```

我們可以使用`continue`關鍵字來跳過本輪循環，直接開啟下一輪。這裡的跳過是指，循環體中，無論後面有沒有未執行的程式碼，一律不執行，比如上面的判斷如果成功，那麼將執行`continue`進行跳過，雖然後面還有列印語句，但是不會再去執行了，而是直接結束目前循環，開啟下一輪。

在某些情況下，我們可能希望提前結束循環：

```kotlin
fun main() {
    for (i in 0..2) {
        if (i == 1) break //我們希望當i等於1時提前結束
        println("傘兵一號盧本偉準備就緒！")
        println("目前i的值為：$i")
    }
}
```

我們可以使用`break`關鍵字來提前終止整個循環，和上面一樣，本輪循環中無論後續還有沒有未執行的程式碼，都不會執行了，而是直接結束整個循環，跳出到循環外部。

雖然使用break和continue關鍵字能夠更方便的控制循環，但是注意在多重循環嵌套下，它只對離它最近的循環生效（就近原則）：

```kotlin
fun main() {
    for (i in 1..3) {
        for (j in 1..3) {
            if (i == j) continue  //當i == j時加速循環
            println("$i, $j")
        }
    }
}
```

這裡的`continue`加速的物件並不是外層的for，而是離它最近的內層for循環，`break`也是同樣的規則：

```kotlin
fun main() {
    for (i in 1..3) {
        for (j in 1..3) {
            if (i == j) break //當i == j時終止循環
            println("$i, $j")
        }
    }
}
```

那麼，要是我們就是想要終止或者是加速外層循環呢？我們可以為循環語句打上標記：

```kotlin
fun main() {
    outer@ for (i in 1..3) {   //在循環語句前，添加 標籤@ 來進行標記
        inner@ for (j in 1..3) {
            if (i == j) break@outer  //break後緊跟要結束的循環標記，當i == j時終止外層循環
            println("$i, $j")
        }
    }
}
```

關於for語句的更多用法，我們會在後續的學習中繼續認識。

### 循環結構（while）

前面我們介紹了for循環語句，我們接著來看第二種while循環，for循環要求我們給一個可遍歷的目標，而while相當於是一個簡化版本，它只需要我們填寫循環的維持條件即可，比如：

```kotlin
while(循環條件) 循環體;
```

相比for循環，while循環更多的用在不明確具體的結束時機的情況下，而for循環更多用於明確知道循環的情況，比如我們現在明確要進行循環10次，此時用for循環會更加合適一些，又比如我們現在只知道當`i`大於10時需要結束循環，但是`i`在循環多少次之後才不滿足循環條件我們並不知道，此時使用while就比較合適了。

```kotlin
fun main() {
    var i = 100 //比如現在我們想看看i不斷除以2得到的結果會是什麼，但是循環次數我們並不明確

    while (i > 0) {   //現在唯一知道的是循環條件，只要大於0那麼就可以繼續除
        println(i)
        i /= 2 //每次循環都除以2
    }
}
```

上面的這種情況就非常適合使用while循環。

和for循環一樣，while也支援使用break和continue來進行循環的控制，以及嵌套使用：

```kotlin
fun main() {
    var i = 100
    while (i > 0) {
        if (i < 10) break
        println(i)
        i /= 2
    }
}
```

我們也可以反轉循環判斷的時機，可以先執行循環內容，然後再做循環條件判斷，這裡要用到`do-while`語句：

```kotlin
fun main() {
    var i = 0 //比如現在我們想看看i不斷除以2得到的結果會是什麼，但是循環次數我們並不明確

    do {  //無論滿不滿足循環條件，先執行循環體裡面的內容
        println("Hello World!")
        i++
    } while (i < 10) //再做判斷，如果判斷成功，開啟下一輪循環，否則結束
}
```

至此，Kotlin程式設計的基礎篇內容就講解完畢了，下一章我們將學習更多Kotlin特性。


————————————————
版權聲明：本文為柏碼知識庫版權所有，禁止一切未經授權的轉載、發布、出售等行為，違者將被追究法律責任。
原文連結：https://www.itbaima.cn/document/urw2e6gg1lprv65w